<script generate>
  var md = require('markdown-it')().use(require('markdown-it-highlightjs'));
  const path = require("path");
  let docs;

  const fs = require("fs");

  const docsDir = inputs.frontMatter.docsDir

  if (!inputs.triggeredBy) {
    // get absolute paths to data files
    docs = getDataFileNames(docsDir + "/**/*.md");
  } else {
    if (inputs.triggeredBy.reason != "Deleted") {
      docs = [inputs.triggeredBy.path];
    } else {
      // else ignore deleted data files.
      resolve();
      return;
    }
  }

  const markdownitfence = require('markdown-it-fence')

  function yourPlugin(md, options) {
    return markdownitfence(md, "airfry", {
      marker: ":",
      render: (tokens, idx, options, env, self) => {
        const template = tokens[idx].info.trim().split(" ")[1]
        const data = JSON.parse(tokens[idx].content.trim())
        return renderTemplate(template, data)
      },
    })
  }
  md.use(yourPlugin)

  let mapped = docs.map((filepath) => {
    const raw = fs.readFileSync(filepath, "utf8");
    const content = frontMatterParse(raw);
    const html = md.render(content.body);
    const title = content.attributes.title;
    const order = content.attributes.order;
    // Use our data paths to specify output paths.
    // Data dir is the absolute path to our data dir
    // We also truncate the '.md' of path names.
    const relPath = filepath.split(dataDir + "/" +
      docsDir + "/")[1].slice(0, -3);

    const group = relPath.split("/")[0]

    return {
      path: relPath,
      data: {
        group: group,
        title: title,
        html: html,
        order: order,
      },
    };
  });


  let toc

  if (inputs.triggeredBy) {
    const page = mapped[0]
    // for a single page, we need to restore
    // the toc from cache and update it
    toc = cache["toc"].data
    const index = toc.findIndex((item) => {
      return item.url == page.path;
    })
    let update = {
      url: page.path,
      title: page.data.title,
      order: page.data.order,
      group: page.data.group,
    }
    if (index == -1) {
      // must be a new page
      toc.push(update)
    } else {
      toc[index] = update;
    }
  } else {
    // a full update rebuilds the table of contents
    toc = mapped.map(item => {
      return {
        url: item.path,
        title: item.data.title,
        order: item.data.order,
        group: item.data.group,
      }
    });
  }

  toc.sort((a, b) => {
    return a.order - b.order
  })

  // store the toc in cache
  cache["toc"] = {
    data: toc,
  }

  generate(mapped);

  resolve({
    watchGlobs: [docsDir + "/**/*.md"],
    cache: cache,
  });
</script>